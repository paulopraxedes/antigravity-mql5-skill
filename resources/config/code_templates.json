{
  "templates": [
    {
      "name": "Expert Advisor Complete Boilerplate",
      "tags": ["ea", "template", "boilerplate", "complete"],
      "code": "//+------------------------------------------------------------------+\n//| Expert initialization function                                   |\n//+------------------------------------------------------------------+\nint OnInit()\n{\n//--- Initialize indicator handles\n   m_maHandle = iMA(_Symbol, PERIOD_CURRENT, InpMAPeriod, 0, MODE_SMA, PRICE_CLOSE);\n   if(m_maHandle == INVALID_HANDLE)\n     {\n      Print(\"Failed to create MA indicator\");\n      return INIT_FAILED;\n     }\n\n//--- Initialize trade object\n   m_trade.SetExpertMagicNumber(InpMagicNumber);\n   m_trade.SetDeviationInPoints(InpDeviation);\n   m_trade.SetTypeFilling(ORDER_FILLING_IOC);\n   \n//--- Initialize symbol info\n   if(!m_symbol.Name(_Symbol))\n     {\n      Print(\"Failed to initialize symbol\");\n      return INIT_FAILED;\n     }\n\n   Print(__FUNCTION__, \" initialized successfully\");\n   return INIT_SUCCEEDED;\n}\n\n//+------------------------------------------------------------------+\n//| Expert deinitialization function                                 |\n//+------------------------------------------------------------------+\nvoid OnDeinit(const int reason)\n{\n//--- CRITICAL: Release all handles\n   IndicatorRelease(m_maHandle);\n   \n//--- Log deinitialization\n   Print(__FUNCTION__, \" deinitialized. Reason: \", reason);\n}"
    },
    {
      "name": "New Bar Detection Function",
      "tags": ["utility", "newbar", "performance", "optimization"],
      "code": "datetime m_prevBarTime = 0;\n\n//+------------------------------------------------------------------+\n//| Check for new bar                                                  |\n//+------------------------------------------------------------------+\nbool IsNewBar()\n{\n   datetime currBarTime = iTime(_Symbol, PERIOD_CURRENT, 0);\n   \n   if(currBarTime == m_prevBarTime)\n      return false;\n      \n   m_prevBarTime = currBarTime;\n   return true;\n}"
    },
    {
      "name": "Risk-Based Position Sizing",
      "tags": ["risk", "sizing", "lots", "moneymanagement"],
      "code": "//+------------------------------------------------------------------+\n//| Calculate lot size based on risk percentage                        |\n//+------------------------------------------------------------------+\ndouble CalculateLotSize(double entryPrice, double stopLossPrice, double riskPercent)\n{\n   if(stopLossPrice <= 0 || riskPercent <= 0)\n      return 0;\n      \n   double riskAmount = AccountInfoDouble(ACCOUNT_BALANCE) * riskPercent / 100.0;\n   double stopDistance = MathAbs(entryPrice - stopLossPrice);\n   double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);\n   double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);\n   \n   if(tickSize == 0 || tickValue == 0)\n      return 0;\n      \n   double stopTicks = stopDistance / tickSize;\n   double lots = riskAmount / (stopTicks * tickValue);\n   \n   return NormalizeLots(lots);\n}\n\n//+------------------------------------------------------------------+\n//| Normalize lot size to symbol constraints                           |\n//+------------------------------------------------------------------+\ndouble NormalizeLots(double lots)\n{\n   double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);\n   double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);\n   double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);\n   \n   lots = MathFloor(lots / lotStep) * lotStep;\n   lots = NormalizeDouble(lots, 2);\n   \n   if(lots < minLot) lots = 0;\n   if(lots > maxLot) lots = maxLot;\n   \n   return lots;\n}"
    },
    {
      "name": "Error Recovery Pattern",
      "tags": ["error", "handling", "retry", "trading"],
      "code": "//+------------------------------------------------------------------+\n//| Execute trade with retry logic                                     |\n//+------------------------------------------------------------------+\nbool ExecuteTradeWithRetry(MqlTradeRequest &request, int maxRetries = 3)\n{\n   MqlTradeResult result;\n   \n   for(int i = 0; i < maxRetries; i++)\n     {\n      ResetLastError();\n      \n      if(OrderSend(request, result))\n        {\n         if(result.retcode == TRADE_RETCODE_DONE || \n            result.retcode == TRADE_RETCODE_DONE_PARTIAL)\n            return true;\n        }\n      \n      // Handle specific errors\n      if(result.retcode == TRADE_RETCODE_REQUOTE)\n        {\n         RefreshRates();\n         request.price = (request.type == ORDER_TYPE_BUY) ? \n                        SymbolInfoDouble(_Symbol, SYMBOL_ASK) : \n                        SymbolInfoDouble(_Symbol, SYMBOL_BID);\n         Sleep(100);\n         continue;\n        }\n      else if(result.retcode == TRADE_RETCODE_MARKET_CLOSED ||\n              result.retcode == TRADE_RETCODE_TRADE_DISABLED ||\n              result.retcode == TRADE_RETCODE_NO_MONEY)\n        {\n         break; // Don't retry these\n        }\n      \n      Sleep(1000 * (i + 1)); // Exponential backoff\n     }\n   \n   return false;\n}"
    },
    {
      "name": "Class Template with RAII",
      "tags": ["class", "oop", "raii", "template"],
      "code": "//+------------------------------------------------------------------+\n//| Class Template                                                     |\n//+------------------------------------------------------------------+\nclass CMyManager\n{\nprivate:\n   bool              m_initialized;\n   int               m_handle;\n   \npublic:\n                     CMyManager() : m_initialized(false), m_handle(INVALID_HANDLE) {}\n                    ~CMyManager() { Deinit(); }\n   \n   bool             Init()\n     {\n      if(m_initialized) return true;\n      \n      // Initialization logic\n      m_handle = iMA(_Symbol, 0, 14, 0, MODE_SMA, PRICE_CLOSE);\n      if(m_handle == INVALID_HANDLE) return false;\n      \n      m_initialized = true;\n      return true;\n     }\n   \n   void             Deinit()\n     {\n      if(!m_initialized) return;\n      \n      // Cleanup logic\n      if(m_handle != INVALID_HANDLE)\n        {\n         IndicatorRelease(m_handle);\n         m_handle = INVALID_HANDLE;\n        }\n      \n      m_initialized = false;\n     }\n   \nprivate:\n   // Prevent copying\n                     CMyManager(const CMyManager&) = delete;\n   CMyManager&      operator=(const CMyManager&) = delete;\n};"
    },
    {
      "name": "Trade Transaction Handler",
      "tags": ["event", "transaction", "monitoring", "logging"],
      "code": "void OnTradeTransaction(const MqlTradeTransaction& trans,\n                       const MqlTradeRequest& request,\n                       const MqlTradeResult& result)\n{\n   switch(trans.type)\n     {\n      case TRADE_TRANSACTION_ORDER_ADD:\n         Print(\"Order added: \", trans.order);\n         break;\n         \n      case TRADE_TRANSACTION_ORDER_DELETE:\n         Print(\"Order deleted: \", trans.order);\n         break;\n         \n      case TRADE_TRANSACTION_HISTORY_ADD:\n         Print(\"Deal executed: \", result.deal, \n               \" Volume: \", result.volume, \n               \" Price: \", result.price);\n         break;\n         \n      case TRADE_TRANSACTION_POSITION:\n         Print(\"Position modified: \", trans.position);\n         break;\n     }\n}"
    }
  ]
}